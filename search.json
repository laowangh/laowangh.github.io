[{"title":"html语法学习","date":"2021-11-13T13:55:31.000Z","url":"/2021/11/13/html%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/","tags":[["HTML","/tags/HTML/"],["博客搭建","/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"],["编程语言","/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"categories":[["HTML","/categories/HTML/"]],"content":" 写在前面：为了新建一个页面，浪费了一晚上时间，奈何根本看不懂，什么也没搞出来。没有学js和css，自己改主题是不太行了，学习一下html，单独建一个页面样式算了，毕竟这样目前看来似乎最简单，权当学习html了。 （本次学习均来自W3school） 基本HTML标签(成对)&lt;html&gt; 与 &lt;/html&gt; 之间的文本描述网页 &lt;body&gt; 与 &lt;/body&gt; 之间的文本是可见的页面内容 HTML 标题是通过&lt;h1&gt; ~ &lt;h6&gt; 等标签进行定义的。 HTML 段落是通过 &lt;p&gt; 标签进行定义的。 HTML 链接是通过&lt;a&gt; 标签进行定义的。 HTML 图像是通过 &lt;img&gt; 标签进行定义的。 &lt;br/&gt;是没有关闭标签的空元素（&lt;br/&gt; 标签定义换行）。 运行结果： HTML属性HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。 属性总是以名称/值对的形式出现，比如：*name=”value”*。 属性总是在 HTML 元素的开始标签中规定。 一些常用属性，属性很多，其他的就只能用到的时候再学习了。 属性 描述 dir 规定元素中内容的文本方向。 id 规定元素的唯一 id。 class 规定元素的一个或多个类名（引用样式表中的类）。 href 指定网址链接。 style 规定元素的行内样式。 align 拥有关于对齐方式的附加信息。 bgcolor 拥有关于背景颜色的附加信息。 始终为属性值加引号: 属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号。 运行结果： "},{"title":"实验考试部分题","date":"2021-11-13T09:31:53.000Z","url":"/2021/11/13/%E5%AE%9E%E9%AA%8C%E8%80%83%E8%AF%95%E9%83%A8%E5%88%86%E9%A2%98/","tags":[["Tag0","/tags/Tag0/"],["Tag1","/tags/Tag1/"],["Tag2","/tags/Tag2/"]],"categories":[["Demo","/categories/Demo/"]]},{"title":"部分算法实验复习整理","date":"2021-11-10T09:35:35.000Z","url":"/2021/11/10/%E9%83%A8%E5%88%86%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["编程","/tags/%E7%BC%96%E7%A8%8B/"]],"categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":" 一次头秃的复习。 0x01 排列问题 题目描述 ​ 输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。 输入 ​ 单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。 输出 ​ 打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。 样例输入 样例输出 主要还是看全排列核心代码吧，不重复情况下的全排列，重复的加个排序就好了。 完整代码 C++ sort()函数升序或降序排序方法： 可以用C++里的模板库（什么也不写，默认升序） 升序：less(); 降序：greater(); 但是现在有一个next_permutation()函数可以直接进行全排列，考试利器啊 升序全排列：next_permutation()； 降序全排列：prev_permutation(); 0x02 跳台阶 题目描述 ​ 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 输入 ​ 多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100) 输出 ​ 每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量. ​ 所得到的结果模1000000007 样例输入 样例输出 设f(n)为跳法数量，最后跳一阶时，跳法是f(n-1),最后跳两阶时，跳法是f(n-2)那么f(n)=f(n-1)+f(n-2)。 很容易知道，f(1)=1；f(2)=2； f(n)=f(n-1)+f(n-2)，n&gt;2；很明显就是斐波那契数列的形式。 0x03 快速幂 题目描述 输入 ​ 多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000) 输出 ​ 对每个样例，输出一行，代表f(x)对100000007取余的结果。 样例输入 样例输出 关键代码，求a^b^(%m)的值。 完整代码 0x04 凯撒加密法 题目描述 ​ 凯撒加密法，或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。​ 例如，当偏移量是左移3的时候： 明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ 密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC 使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：​ 明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG​ 密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ​ 现在给定你一个字符串S（长度不会超过1000000）和一个整数k（-1000000000&lt;=k&lt;=1000000000），分别代表接受者收到的密文和在加密该密文时向后的偏移量，你的任务是计算出原来的明文​ 注意：只有字母在加密时才会发生偏移，其它字符保持不变 输入 ​ 输入包含多组数据，其中第一行为数据组数T（T&lt;=10）​ 每组数据第一行为一个字符串S，由数字、字母以及常见字符组成（不含空格），第二行为一个整数k代表加密时向后的偏移量（|S|&lt;=1000000,-1000000000&lt;=k&lt;=1000000000） 输出 ​ 对每组数据，输出一行字符串，代表输入中的密文对应的明文。 样例输入 样例输出 凯撒还是挺简单的，关键代码 完整代码 0x05 Vigenère 密码 题目描述 ​ 16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法——Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。 ​ 在密码学中，我们称需要加密的信息为明文，用 MM 表示；称加密后的信息为 密文，用 CC 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 kk。 在 Vigenère 密码中，密钥 kk 是一个字母串，k=k1k2…kn。当明文 M = m1m2…mn 时，得到的密文 C = c1c2…cn ，其中 ci = mi ® ki，运算 ® 的规则如下表所示：​​ Vigenère 加密在操作时需要注意： ® 运算忽略参与运算的字母的大小写，并保持字母在明文 MM 中的大小写形式； 当明文 MM 的长度大于密钥 kk 的长度时，将密钥 kk 重复使用。 例如，明文 M=M=Helloworld，密钥 k=k=abc时，密文 C=C=Hfnlpyosnd。​ 输入 ​ 第一行为一个字符串，表示密钥 kk，长度不超过 100100，其中仅包含大小写字母。 ​ 第二行为一个字符串，表示经加密后的密文，长度不超过 10001000，其中仅包含大小写字母。 输出 输出共 1 行，一个字符串，表示输入密钥和密文所对应的明文。 样例输入 样例输出 这个跟凯撒一样啊，稍微改下就行了。 0x06 最长子序列 题目描述 ​ 在一个数组中找出和最大的连续几个数。（至少包含一个数） ​ 例如： ​ 数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6. 输入 ​ 第一行输入一个不超过1000的整数n。 ​ 第二行输入n个整数A[i]。 输出 ​ 输出一个整数，表示最大的和。 样例输入 样例输出 没时间了，后面直接背代码吧。 0x07 三值排序 题目描述 ​ 排序是一种很频繁的计算任务。一个实际的例子是，当我们给某项竞赛的优胜者按金银铜牌排序的时候。在这个任务中可能的值只有三种1，2和3。我们用交换的方法把他排成升序的。 ​ 写一个程序计算出，计算出的一个包括1、2、3三种值的数字序列，排成升序所需的最少交换次数。 输入 ​ 输入第1行为类别的数量N（1≤N≤1000） ​ 输入第2行到第N+1行，每行包括一个数字（1或2或3）。 输出 ​ 输出包含一行，为排成升序所需的最少交换次数。 样例输入 样例输出 0x08 最长公共子序列 题目描述 ​ 一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。 输入 ​ 第一行两个字符串用空格分开。两个串的长度均小于2000 。 输出 ​ 最长子串的长度。 样例输入 样例输出 0x09 求第k小 题目描述 ​ 给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。 输入 ​ 一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。 输出 ​ 输出一行，输出第k小数。 样例输入 样例输出 怎么说呢，这道题本来很长，但是我们可以直接用sort（）函数啊，偷奸耍滑第一名。 0x0a 求数组的最长递减子序列 题目描述 ​ 给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。 输入 ​ 输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。 输出 ​ 输出最长递减子序列，数字之间有一个空格。 样例输入 样例输出 0x0b 单词排序 题目描述 ​ 小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。 输入 ​ 输入包含两行。 ​ 第一行仅包括一个正整数N(0&lt;N≤26)。 ​ 第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。 ​ 单个单词长度不超过1010。 输出 ​ 输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。 样例输入 样例输出 似乎挺简单 0x0c 进制转换这道题没什么好说的，就是进制转换，我们可以直接用c的输出： 或者**itoa()**函数，将一个10进制的数转化为n进制的值、其返回值为char型。 0x0d 沙子的质量 题目描述 ​ 设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。 输入 ​ 第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。 输出 ​ 合并的最小代价。 样例输入 样例输出 肝不动了，就这样随缘吧 "}]